using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using ObjParser.Types;

namespace ObjParser
{
    public class Obj
    {
        public List<Vertex> VertexList;
        public List<Face> FaceList;
        public List<TextureVertex> TextureList;
        public List<NormalVertex> NormalList;

        public int VertexListShift { get; set; } = 0;
        public int NormalListShift { get; set; } = 0;

        public Extent Size { get; set; }

        public string UseMtl { get; set; }
        public string Mtl { get; set; }

        /// <summary>
        /// Constructor. Initializes VertexList, FaceList and TextureList.
        /// </summary>
	    public Obj()
        {
            VertexList = new List<Vertex>();
            FaceList = new List<Face>();
            TextureList = new List<TextureVertex>();
            NormalList = new List<NormalVertex>();
        }

        /// <summary>
        /// Load .obj from a filepath.
        /// </summary>
        /// <param name="file"></param>
        public void LoadObj(string path)
        {
            LoadObj(File.ReadAllLines(path));
        }

        /// <summary>
        /// Load .obj from a stream.
        /// </summary>
        /// <param name="file"></param>
	    public void LoadObj(Stream data)
        {
            using (var reader = new StreamReader(data))
            {
                LoadObj(reader.ReadToEnd().Split(Environment.NewLine.ToCharArray()));
            }
        }

        /// <summary>
        /// Load .obj from a list of strings.
        /// </summary>
        /// <param name="data"></param>
	    public void LoadObj(IEnumerable<string> data)
        {
            var faceId = 0;
            foreach (var (line, index) in data.Select((value, i) => (value, i)))
            {
                processLine(line, index, ref faceId);
            }

            updateSize();
        }

        public void WriteObjFile(string path, string[] headerStrings)
        {
            using (var outStream = File.OpenWrite(path))
            using (var writer = new StreamWriter(outStream))
            {
                // Write some header data
                WriteHeader(writer, headerStrings);

                if (!string.IsNullOrEmpty(Mtl))
                {
                    writer.WriteLine("mtllib " + Mtl);
                }

                VertexList.ForEach(v => writer.WriteLine(v));
                TextureList.ForEach(tv => writer.WriteLine(tv));
                string lastUseMtl = "";
                foreach (Face face in FaceList)
                {
                    if (face.UseMtl != null && !face.UseMtl.Equals(lastUseMtl))
                    {
                        writer.WriteLine("usemtl " + face.UseMtl);
                        lastUseMtl = face.UseMtl;
                    }
                    writer.WriteLine(face);
                }
            }
        }

        private void WriteHeader(StreamWriter writer, string[] headerStrings)
        {
            if (headerStrings == null || headerStrings.Length == 0)
            {
                writer.WriteLine("# Generated by ObjParser");
                return;
            }

            foreach (var line in headerStrings)
            {
                writer.WriteLine("# " + line);
            }
        }

        /// <summary>
        /// Sets our global object size with an extent object
        /// </summary>
        private void updateSize()
        {
            // If there are no vertices then size should be 0.
            Size = GetObjSize(VertexList);
        }

        public static Extent GetObjSize(IEnumerable<Vertex> verts)
        {
            Extent size = null;
            // If there are no vertices then size should be 0.
            if (verts.Count() == 0)
            {
                size = new Extent
                {
                    XMax = 0,
                    XMin = 0,
                    YMax = 0,
                    YMin = 0,
                    ZMax = 0,
                    ZMin = 0
                };

                // Avoid an exception below if VertexList was empty.
                return size;
            }

            size = new Extent
            {
                XMax = verts.Max(v => v.X),
                XMin = verts.Min(v => v.X),
                YMax = verts.Max(v => v.Y),
                YMin = verts.Min(v => v.Y),
                ZMax = verts.Max(v => v.Z),
                ZMin = verts.Min(v => v.Z)
            };

            return size;
        }

        /// <summary>
        /// Parses and loads a line from an OBJ file.
        /// Currently only supports V, VT, F and MTLLIB prefixes
        /// </summary>		
        private void processLine(string line, int index, ref int faceId)
        {
            string[] parts = line.Split(new char[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);

            if (parts.Length > 0)
            {
                switch (parts[0])
                {
                    case "usemtl":
                        UseMtl = parts[1];
                        break;
                    case "mtllib":
                        Mtl = parts[1];
                        break;
                    case "v":
                        Vertex v = new Vertex();
                        v.LoadFromStringArray(parts);
                        VertexList.Add(v);
                        v.Index = VertexList.Count() + VertexListShift;
                        break;
                    case "f":
                        Face f = new Face();
                        f.Id = faceId;
                        f.LoadFromStringArray(parts);
                        f.UseMtl = UseMtl;
                        FaceList.Add(f);
                        faceId++;
                        break;
                    case "vt":
                        TextureVertex vt = new TextureVertex();
                        vt.LoadFromStringArray(parts);
                        TextureList.Add(vt);
                        vt.Index = TextureList.Count();
                        break;
                    case "vn":
                        NormalVertex vn = new NormalVertex();
                        vn.LoadFromStringArray(parts);
                        NormalList.Add(vn);
                        vn.Index = NormalList.Count() + NormalListShift;
                        break;
                }
            }
        }

    }
}
